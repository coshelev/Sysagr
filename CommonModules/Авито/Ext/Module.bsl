 Функция GreenApiWhatsapp_SendMessage(Получатель, Содержание)Экспорт
	// Отправляет исходящее текстовое сообщение и НЕ РЕГИСТРИРУЕТ его в РС.АвитоСообщения  конкретному получателю (пример его chatid = "79001234565@c.us"
	//или в группу (пример chatid группы = 79001234567-1587570015@g.us)
	//Параметры:
	// Получатель	(строка) 	- Whatsapp-телефонный номер получателя (например 900123456, дальнейшее преобразование в chatid 
	//							  внутри функции) или chatid группы (например 79001234567-1587570015@g.us)								
	// Содержание 	(строка) 	- текст сообщения
	        
	Доступно =  ТипЗнч(Получатель) = Тип("Строка") И ТипЗнч(Содержание) = Тип("Строка") И ЗначениеЗаполнено(Получатель) И ЗначениеЗаполнено(Содержание);
	Если Не Доступно Тогда
		ЗаписьЖурналаРегистрации("Отправь", УровеньЖурналаРегистрации.Ошибка, ,   "Получатель = " + Получатель + ", Содержание = "+Содержание, "ошибка: неверные типы или значения аргументов");
		Возврат "ошибка: неверные типы или значения аргументов"
	КонецЕсли;
	
	//Отправить сообщение - сделать POST 
	//POST https://api.green-api.com/waInstance{{idInstance}}/SendMessage/{{apiTokenInstance}}
	//см. описание на https://green-api.com/docs/api/sending/SendMessage/
	
	//Определи это сообщение конкретному пользователю или групповое
	Если СтрНайти(Получатель, "@g.us") > 0 Тогда
		//Это групповое сообщение, на вход должно поступить корректный, well-formed, chatid
		chat_id = Получатель;
	Иначе
		//Сообщение конкретному получателю. На вход должен поступить только Whatsapp-номер телефона, например 9103827006 
		//Сформируй chat_id. Например, для получателя с номером 9103827006, chat_id должен быть "79103827006@c.us" 
		chat_id = ?(СтрНайти(Получатель, "@c.us")=0, Получатель + "@c.us", Получатель);
		chat_id = ?(Лев(chat_id,1)<>7, "7"+chat_id, chat_id);
	КонецЕсли;
	
	url   = "https://api.green-api.com/waInstance19931/SendMessage/b3ec59c13b0b83332b1ea858d1bf94423ee0588290feab5ecd"; 
	body  = СтрШаблон("{""chatId"": ""%1"",	""message"": ""%2""}", chat_id, Содержание);
	
	Кмд   = СтрШаблон("curl --request POST %1 -H ""Content-Type:application/json"" -H ""Accept"":""*/*"" -H ""Accept-Encoding"":""gzip,deflate,br"" --data %2", url ,body);	
	Ответ = Авито.CURL_HttpResponse(Кмд);
	
	Если Ответ.КодСостояния <> 200 Тогда
		ОписаниеОшибки = СтрШаблон("ошибка: неверный ответ на http-запрос, код состояния = %1",  Ответ.КодСостояния);
		ЗаписьЖурналаРегистрации("Отправь", УровеньЖурналаРегистрации.Ошибка, , СтрШаблон("chat_id = %1, Содержание = %2", chat_id, Содержание), ОписаниеОшибки);
		Возврат ОписаниеОшибки;
	КонецЕсли;
	
	Возврат "";
КонецФункции      

Функция CURL_HttpResponse(Стр, ИмяФайлаДвДанных="") Экспорт 
	//Возвращает HTTP-Ответ
	//Вх.параметры: Стр - строка с командой CURL; ИмяФайлаДвДанных - полное имя файла (с путем), двоичные данные которого должны представлять тело запроса (используется для PUT) 
	//Пример: 
	//	curl --request POST 'https://luidor-expert.ru/api/external/1c/chat/116316fe-2185-4b3f-a6a6-8d79dff7fd09/' -H 'Content-Type:application/json' -d '{"type":"text", "message":{"text":"Спасибо за обращение, принято в работу"}}'
	//	curl -X POST 'https://www.googleapis.com/oauth2/v4/token' -H 'Content-Type:application/x-www-form-urlencoded' -d 'grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Ajwt-bearer&assertion'
		
	Доступно = ТипЗнч(Стр) = Тип("Строка") И ЗначениеЗаполнено(Стр);			
	Если Не Доступно Тогда
		Возврат "ошибка";
	КонецЕсли;   

	//Инициализация пользователя и пароля HTTP-Соединения
	Пользователь = "";
	Пароль		 = "";
	
	//Найди подстроку -u за которой следует имя пользователя и пароль как например здесь
	//curl -u username:password 'https://cloud.example.com/remote.php/dav/files/username/folder' -X PROPFIND --data '<?xml version="1.0" encoding="UTF-8"?>
	u_pos = СтрНайти(Стр, "-u ");	
	Если u_pos > 0 Тогда
		ПользПарольНачалоПоз    = u_pos+3;
		ПользПарольОкончаниеПоз = СтрНайти(Стр, " ", ,ПользПарольНачалоПоз);
		ПользПароль 			= Сред(Стр, ПользПарольНачалоПоз, ПользПарольОкончаниеПоз - ПользПарольНачалоПоз);  
		ПользПарольРазд			= СтрРазделить(ПользПароль, ":", Ложь);
		Пользователь 		 	= ПользПарольРазд[0];
        Пароль			 		= ПользПарольРазд[1]; 
	КонецЕсли; 
		
	//Найди подстроку --request или -X, за ней - метод:    
	Метод = "";
	
	request_pos = СтрНайти(Стр, "--request");
	request_pos = ?(request_pos = 0, СтрНайти(Стр, "-X"), request_pos);
	Если request_pos =0 Тогда
		ЗаписьЖурналаРегистрации("CURL", УровеньЖурналаРегистрации.Ошибка, , Стр, "не найдено ключевое слово ""--request"" или ""-X"" ");
		Возврат "ошибка: не найдено ключевое слово ""--request"" или ""-X"" ";
	КонецЕсли; 
	
	Метод = "";
	method_pos = СтрНайти(Стр, "GET", , request_pos+1); 
	Метод = ?(method_pos > 0, "GET", Метод);
	
	method_pos = ?(method_pos = 0, СтрНайти(Стр, "POST", , request_pos+1), method_pos); 
	Метод	   = ?(Метод = "" И method_pos > 0, "POST", Метод);
	
	method_pos = ?(method_pos = 0, СтрНайти(Стр, "MKCOL", , request_pos+1), method_pos); 
	Метод	   = ?(Метод = "" И method_pos > 0, "MKCOL", Метод);
	
	method_pos = ?(method_pos = 0, СтрНайти(Стр, "DELETE", , request_pos+1), method_pos); 
	Метод	   = ?(Метод = "" И method_pos > 0, "DELETE", Метод);  
	
	Если Метод = "" Тогда
		ЗаписьЖурналаРегистрации("CURL", УровеньЖурналаРегистрации.Ошибка, , Стр, "не найден HTTP метод");
		Возврат "ошибка: не найден HTTP метод";
	КонецЕсли;
	
	url = "";
	url_pos_start = method_pos + СтрДлина(Метод)+1; 
	url_pos_end   = СтрНайти(Стр, " ", , url_pos_start, 1);  
	url = СокрЛП(Сред(Стр, url_pos_start, url_pos_end-url_pos_start));  
	
	//Удали апострофы и кавычки, обрамляющие url
	url = СтрЗаменить(url, """", ""); 
	url = СтрЗаменить(url, "'", "");
	
	Если СтрДлина(url)<3 Тогда
		ЗаписьЖурналаРегистрации("CURL", УровеньЖурналаРегистрации.Ошибка, , Стр, "не найден URL");
		Возврат "ошибка: не найден URL";	
	КонецЕсли;  
	
    //Определи тип соединения (протокол): http или https
	ЗащищенноеСоединение = ?(СтрНайти(url, "https")>0, Новый ЗащищенноеСоединениеOpenSSL, Неопределено);  
	
	//Убери из url название протокола "https://" или "http://"
	ПозицияСлешаПротокола = СтрНайти(url, "://");
	Если ПозицияСлешаПротокола =0 Тогда
		ЗаписьЖурналаРегистрации("CURL", УровеньЖурналаРегистрации.Ошибка, , Стр, "ошибка разбора url");
		Возврат "ошибка"
	КонецЕсли;
	Протокол = Лев(url, ПозицияСлешаПротокола+2);
	url 	 = СтрЗаменить(url, Протокол, ""); 
	
	//Выдели порт сервера, например из строки https://api.direct.yandex.com:443/json/v5/report
	port		 			= "";        
	ПервыйСлешПоз			= СтрНайти(url, "/", ,3);
	ПозицияДвоеточияПорта 	= СтрНайти(url, ":"); 
	Доступно = ПозицияДвоеточияПорта > 0 И ПозицияДвоеточияПорта < ПервыйСлешПоз;
	Если Доступно Тогда
		ПозицияСлешаПорта		= СтрНайти(url, "/",,ПозицияДвоеточияПорта,1);
		port = Сред(url, ПозицияДвоеточияПорта+1, ПозицияСлешаПорта - ПозицияДвоеточияПорта - 1);
	    url	 = СтрЗаменить(url, ":"+port, ""); 
	КонецЕсли;     
	
	//Выдели имя сервера (хоста)
	ПозицияСлешаСервера = СтрНайти(url, "/");
	Сервер	 			= Лев(url,ПозицияСлешаСервера-1);
		
	//Выдели адрес сервера
	Адрес = Прав(url, СтрДлина(url)-ПозицияСлешаСервера+1);
	
	//Выполни запрос   
	Соединение 	= ?(port = "", 
					Новый HTTPСоединение(Сервер,,Пользователь,Пароль,,,ЗащищенноеСоединение), 
					Новый HTTPСоединение(Сервер, Число(port),Пользователь,Пароль,,,ЗащищенноеСоединение));
	
	Запрос 		= Новый HTTPЗапрос(Адрес);  
	
	//Обработай опцию -H или --header (заголовки). Их может быть несколько в одной команде, например curl -X POST 'https://apiauto.ru/1.0/auth/login' -H 'x-authorization:cheb003...' -H 'Content-Type:application/json' -d '{"login":"Lui...","password":"lui..."}'   
	_Стр = СтрЗаменить(Стр, "--header", "-H");  	
	H_pos = 1;
	Для i = 1 По СтрДлина(_Стр) Цикл
		Н_pos = СтрНайти(Стр, "-H '",,H_pos);
		Если Н_pos = 0 Тогда
			Прервать;
		КонецЕсли;
		
		colon_pos = СтрНайти(_Стр, ":", ,Н_pos);
		Если colon_pos = 0 Тогда
			ЗаписьЖурналаРегистрации("CURL", УровеньЖурналаРегистрации.Ошибка, , Стр, "не найден символ "";"" в заголовке");
			Возврат "ошибка: не найден символ "";"" в заголовке";
		КонецЕсли;  
		
		lastApostrophe_pos = СтрНайти(_Стр, "' ", ,colon_pos); 
		Если lastApostrophe_pos = 0 Тогда
			Прервать;
		КонецЕсли;
		КлючЗначениеСтрокой = Сред(_Стр, Н_pos+4, lastApostrophe_pos -  (Н_pos+4));
		КлючЗначение = СтрРазделить(КлючЗначениеСтрокой, ":");     
        Запрос.Заголовки.Вставить(СокрЛП(КлючЗначение[0]), СокрЛП(КлючЗначение[1]));   
		
		//Для поиска следующего заголовка
		H_pos = lastApostrophe_pos;
	КонецЦикла;
	
	//Блок данных: -d или --data        
	_Стр 		= СтрЗаменить(Стр, "--data", "-d");
	dPos 		= СтрНайти(_Стр, "-d '");  
	dEndPos		= ?(dPos > 0, СтрНайти(_Стр, "'", , dPos + 5, 1), 0); 
	ТелоЗапроса = ?(dEndPos > 0, Сред(_Стр, dPos+4, dEndPos - dPos-4), "");
	Если ТелоЗапроса <> "" Тогда
		Запрос.УстановитьТелоИзСтроки(ТелоЗапроса);	
	КонецЕсли;  
    	
	//Обработай опцию "--form": в тело запроса добавь пары ключ-значение 
	Слова 	= СтрРазделить(Стр, " ");	
	Инд 	= Слова.Найти("--form");
	
	Доступно = 	Метод = "POST"  И Инд <> Неопределено;
	Если Доступно Тогда				
		//Пример отправки в POSTMANе
		//------------------------------------------------------------------------------------
		//POST /services/spellservice.json/checkText HTTP/1.1
		//Host: speller.yandex.net
		//Content-Length: 316
		//Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW
		//
		//----WebKitFormBoundary7MA4YWxkTrZu0gW
		//Content-Disposition: form-data; name="text"
		//
		//синчхрафазатрон
		//----WebKitFormBoundary7MA4YWxkTrZu0gW
		//Content-Disposition: form-data; name="text2"
		//
		//grep
		//----WebKitFormBoundary7MA4YWxkTrZu0gW
		//Content-Disposition: form-data; name="text3"
		//
		//hello
		//----WebKitFormBoundary7MA4YWxkTrZu0gW
		//-------------------------------------------------------------------------------------			
											
		//Структура должна быть обязательно именно такой, повторяя каждый отступ и перенос (см. https://infostart.ru/1c/articles/1510979/):
		//Разделитель, Символ.ВК, Символ.ПС		(1)
		//Описание, Символ.ВК, Символ.ПС		(2)
		//ОписаниеТипа, Символ.ВК, Символ.ПС,	(3)	
		//Символ.ВК, Символ.ПС					(4)
		//(Двочные)Данные, Символ.ВК, Вимвол.ПС	(5)
		//Разделитель			                (6)
		
		Данные 	= Слова[Инд+1];
		Части 	= СтрРазделить(Данные, "--form", Ложь);
		
		//Разделитель -  все что угодно, можно даже руками указать "razzdell", главное что бы оно было уникальное во всем тексте тела  (см. https://infostart.ru/1c/articles/1510979/)
		//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		Разделитель = СтрЗаменить(Новый УникальныйИдентификатор, "-", "");
		
		Тело = Новый ПотокВПамяти();
		ЗаписьДанных = Новый ЗаписьДанных(Тело, , , Символы.ВК + Символы.ПС, ""); // переопределение разделителя строки. По умолчанию только ПС, делаем ВК+ПС.   
		Для Каждого Часть Из Части Цикл
			ПараПараметрЗначение 	= 	СтрРазделить(Часть, "=");
			ИмяПараметра 			= 	ПараПараметрЗначение[0];
			ЗначениеПараметра 		=	ПараПараметрЗначение[1]; 

			ЗаписьДанных.ЗаписатьСтроку("--" + Разделитель);														// Разделитель, Символ.ВК, Символ.ПС		(1)
			ИмяПараметра = "text";
			ЗаписьДанных.ЗаписатьСтроку("Content-Disposition: form-data; name=" + ИмяПараметра);					//Описание, Символ.ВК, Символ.ПС		(2)
			ЗаписьДанных.ЗаписатьСтроку(СтрШаблон("Content-Type: multipart/form-data; boundary=%1", Разделитель));
			ЗаписьДанных.ЗаписатьСтроку(""); 																		// пустая строка для доп переноса и воспроизведения структуры тела
			ЗаписьДанных.ЗаписатьСтроку(ЗначениеПараметра);
			ЗаписьДанных.ЗаписатьСтроку(""); 																		// записать не добавляет переносов, добавляем их пустой строкой
			ЗаписьДанных.ЗаписатьСтроку("--" + Разделитель + "--"); 												// добавляются еще доп переносы, но они уже не на что не влияют, так же после разделителя добавляем "--", должно обозначать конец тела
		КонецЦикла;
		ЗаписьДанных.Закрыть();
		ДанныеТела = Тело.ЗакрытьИПолучитьДвоичныеДанные(); 														// получаем дело в дд, можно и через запись в файл, просто лишний раз не трогаем диски и не делаем доп операций
		
		Запрос.УстановитьТелоИзДвоичныхДанных(ДанныеТела);															// установи тело
		Запрос.Заголовки.Вставить("Content-Length", XMLСтрока(ДанныеТела.Размер()));
		Запрос.Заголовки.Вставить("Content-Type", 	"multipart/form-data; boundary=" + разделитель);
	КонецЕсли; 
	
	//Работа с облаком NextCloud - выгрузка файла, см. описание https://docs.nextcloud.com/server/22/developer_manual/client_apis/WebDAV/basic.html#uploading-files                   
	Доступно = Метод = "PUT" И Сервер = "nxcloud.luidor.it" И ЗначениеЗаполнено(ИмяФайлаДвДанных);	
	Если Доступно Тогда      		
		Чт 		= Новый ЧтениеДанных(ИмяФайлаДвДанных);
		Рез 	= Чт.Прочитать();
		Бинари 	= Рез.ПолучитьДвоичныеДанные();
		Запрос.УстановитьТелоИзДвоичныхДанных(Бинари);	
		Чт.Закрыть();
	КонецЕсли;
	
	//MKCOL (создай папку), в частности используется для работы с облаком NextCloud
	Доступно = Метод = "MKCOL";
	Если Доступно Тогда
		//Ничего дополнительного не требуется
	КонецЕсли; 
	
	//Удаление папки или файла ,в частности используется для работы с облаком NextCloud
	Доступно = Метод = "DELETE";
	Если Доступно Тогда
		//Ничего дополнительного не требуется
	КонецЕсли;
		
	Попытка
		HTTPОтвет = Соединение.ВызватьHTTPМетод(Метод, Запрос);
	Исключение
		ЗаписьЖурналаРегистрации("CURL", УровеньЖурналаРегистрации.Ошибка, , Стр, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		Возврат "ошибка";
	КонецПопытки;
	  
	Возврат HTTPОтвет; 
	
КонецФункции    

Функция CURL(Стр, ИмяФайлаДвДанных="") Экспорт    
	//Возвращает "ошибка" в случае неупеха или структуру с полями: 
	//	"Заголовки" - Заголовки HTTPОтвета, "ТелоСтрокой" - тело строкой ответа HTTPОтвета, "ТелоДвДанными" - тело двоичными данными HTTPОтвета
	//Вх.параметры
		//Стр - строка с командой CURL,
		//ИмяФайлаДвДанных - полное имя файла (с путем), двоичные данные которого должны представлять тело запроса (используется для PUT)
	Доступно = 		ТипЗнч(Стр) 	= Тип("Строка")
					И	ЗначениеЗаполнено(Стр);			
	Если Не Доступно Тогда
		Возврат "ошибка";
	КонецЕсли;
	
	HTTPОтвет = Авито.CURL_HttpResponse(Стр, ИмяФайлаДвДанных);   
	
	Доступно = 		ТипЗнч(HTTPОтвет) = Тип("Строка")
				И 	HTTPОтвет = "ошибка";
	Если Доступно Тогда
		Возврат "ошибка"
	КонецЕсли;
	
	//Если оказались здесь, значит возвращаемый тип значения "HTTPОтвет"
	//------------------------------------------------------------------
	Доступно = (HTTPОтвет.КодСостояния = 200 Или HTTPОтвет.КодСостояния = 201 Или HTTPОтвет.КодСостояния = 204);
	Если Не Доступно Тогда
		ЗаписьЖурналаРегистрации("CURL", УровеньЖурналаРегистрации.Ошибка, , СтрШаблон("Стр = %1" ,Стр), СтрШаблон("ошибка: не получен ресурс. Код состояния = %1", HTTPОтвет.КодСостояния));
		Возврат "ошибка";
	КонецЕсли;    
	            
	Возврат HTTPОтвет;
КонецФункции  

Функция CURL_Str(Стр, ИмяФайлаДвДанных = "") Экспорт 
	//Возвращает строку из HTTP-Ответа в случае успеха или "ошибка" в случае неуспеха 
	//Вх.параметры
		//Стр 				- текст команды CURL,
		//ИмяФайлаДвДанных 	- полное имя файла (с путем), двоичные данные которого должны представлять тело HTTP-Запроса (используется для PUT)

	HTTPОтвет = Авито.CURL(Стр, ИмяФайлаДвДанных = ""); 
	Если HTTPОтвет = "ошибка" Тогда
		Возврат "ошибка"
	КонецЕсли;
	Отв = HTTPОтвет.ПолучитьТелоКакСтроку();
	Возврат Отв;
КонецФункции    

Функция CURL_Binary(Стр, ИмяФайлаДвДанных = "") Экспорт 
	//Возвращает двоичные данные из HTTP-Ответа в случае успеха или "ошибка" в случае неуспеха  
	//Вх.параметры
		//Стр 				- текст команды CURL,
		//ИмяФайлаДвДанных 	- полное имя файла (с путем), двоичные данные которого должны представлять тело HTTP-Запроса (используется для PUT)

	HTTPОтвет = Авито.CURL(Стр, ИмяФайлаДвДанных = ""); 
	Если HTTPОтвет = "ошибка" Тогда
		Возврат "ошибка"
	КонецЕсли;
	Отв = HTTPОтвет.ПолучитьТелоКакДвоичныеДанные();
	Возврат Отв;
КонецФункции 

Функция ПрочитатьЗначениеJson(Стр) Экспорт          
	//Аналог javascript JSON.parse() - возврат объекта из json-строки
	//----------------------------------------------------------------
	
	Доступно = ТипЗнч(Стр) = Тип("Строка") И ЗначениеЗаполнено(Стр);
	Если Не Доступно Тогда
		ЗаписьЖурналаРегистрации("ПрочитатьЗначениеJson", УровеньЖурналаРегистрации.Ошибка,, СтрШаблон("Стр = %1", Стр), "неверные параметры");			
		Возврат "error";				
	КонецЕсли;			
	
	Стр = СтрЗаменить(Стр, "<br>", "");
	
	Чт = Новый ЧтениеJson();
	Чт.УстановитьСтроку(Стр);
	Ошибка = Ложь;  
	
	//Попытка получить структуру
	Попытка
		Об = ПрочитатьJson(Чт);
	Исключение   
		Ошибка = Истина;
	КонецПопытки; 
	
	Если Не Ошибка Тогда
		Возврат Об;
	КонецЕсли;
	
	//Если ПрочитатьJson(Чт) вызвало исключение, то произошло смещение в объекте Чт,
	//спозиционируемся снова на начало, и прочитаем в соответствие
	//-------------------------------------------------------------------------------
	Чт = Новый ЧтениеJson();
	Чт.УстановитьСтроку(Стр);
	Попытка
		Об = ПрочитатьJson(Чт, Истина);
	Исключение   
		Возврат "error";
	КонецПопытки; 
	
	Возврат Об;
КонецФункции


